######################## Luminal A vs Basal like ############################################
gdata=read.table("gene_exp_580_cases.txt")
glist=read.table("standard_17812_genes_list.txt")
path_genes=read.table("cellcycle.txt")
seq=match(path_genes[,1],glist[,1])
seq=na.omit(seq)
selected=gdata[seq,]
selected=t(selected)

LA=reorder[1:221,]
SL=reorder[466:580,]
set.seed(123)

library(DNetFinder)
beta1npn=lassoNPN(LA)
beta2npn=lassoNPN(SL)

myDN_005=DNetNPN(LA,SL,beta1npn,beta2npn,0.05)
sum(myDN_005)
myDN_010=DNetNPN(LA,SL,beta1npn,beta2npn,0.10)
sum(myDN_010)
myDN_015=DNetNPN(LA,SL,beta1npn,beta2npn,0.15)
sum(myDN_015)
myDN_020=DNetNPN(LA,SL,beta1npn,beta2npn,0.20)
sum(myDN_020)
myDN_025=DNetNPN(LA,SL,beta1npn,beta2npn,0.25)
sum(myDN_025)

FDR=c(0.05,0.1,0.15,0.2,0.25)
No.diff.edges=c(38,54,76,88,108)
plot(FDR,No.diff.edges,ylim=c(0,110),type="o",lwd=2,pch=19,col="red",main="FDR vs No. of differential edges")

######################## Luminal B vs Basal like ############################################
gdata=read.table("gene_exp_580_cases.txt")
glist=read.table("standard_17812_genes_list.txt")
path_genes=read.table("cellcycle.txt")
seq=match(path_genes[,1],glist[,1])
seq=na.omit(seq)
selected=gdata[seq,]
selected=t(selected)
LA=reorder[1:221,]
SL=reorder[(466-118):466,]

library(DNetFinder)
beta1npn=lassoNPN(LA)
beta2npn=lassoNPN(SL)

myDN_005=DNetNPN(LA,SL,beta1npn,beta2npn,0.05)
sum(myDN_005)
myDN_010=DNetNPN(LA,SL,beta1npn,beta2npn,0.10)
sum(myDN_010)
myDN_015=DNetNPN(LA,SL,beta1npn,beta2npn,0.15)
sum(myDN_015)
myDN_020=DNetNPN(LA,SL,beta1npn,beta2npn,0.20)
sum(myDN_020)

library(network)
clus1=as.matrix(myDN_005)
g=network(clus1,directed=F)
plot(g,label=path_genes[,1],label.pos=1,label.cex=0.8,vertex.col="green",edge.lwd=1,edge.col="red",displayisolates=F)

library(network)
clus1=as.matrix(myDN_010)
g=network(clus1,directed=F)
plot(g,label=path_genes[,1],label.pos=1,label.cex=0.8,vertex.col="green",edge.lwd=1,edge.col="red",displayisolates=F)

library(network)
clus1=as.matrix(myDN_015)
g=network(clus1,directed=F)
plot(g,label=path_genes[,1],label.pos=1,label.cex=0.8,vertex.col="green",edge.lwd=1,edge.col="red",displayisolates=F)

library(network)
clus1=as.matrix(myDN_020)
g=network(clus1,directed=F)
plot(g,label=path_genes[,1],label.pos=1,label.cex=0.8,vertex.col="green",edge.lwd=1,edge.col="red",displayisolates=F)

##################################################################

library(corpcor)
p=200
PM1=diag(p)
for(i in 1:(p-1)){
PM1[i,i+1]=0.6
PM1[i+1,i]=0.6
}
PM2=PM1
for(i in 1:50){
PM2[i,i+1]=0.1
PM2[i+1,i]=0.1
}
PM1=PM1+0.2*diag(p)
PM2=PM2+0.2*diag(p)

is.positive.definite(PM1)
is.positive.definite(PM2)
is.positive.definite(solve(PM1))
is.positive.definite(solve(PM2))

library(MASS)
mysample1=mvrnorm(n=100,mu=rep(0,p),Sigma=solve(PM1),tol=1e-6,empirical=FALSE,EISPACK=FALSE)
mysample2=mvrnorm(n=100,mu=rep(0,p),Sigma=solve(PM2),tol=1e-6,empirical=FALSE,EISPACK=FALSE)

write.table(round(mysample1,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/condition1.txt",row.names=F,col.names=F,quote=F)
write.table(round(mysample2,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/condition2.txt",row.names=F,col.names=F,quote=F)


library(DNetFinder)
data1=read.table("/users/qingyangzhang/desktop/DNetFinder_package/condition1.txt",header=F)
data2=read.table("/users/qingyangzhang/desktop/DNetFinder_package/condition2.txt",header=F)
beta1ggm=lassoGGM(data1)
beta2ggm=lassoGGM(data2)
beta1npn=lassoNPN(data1)
beta2npn=lassoNPN(data2)
write.table(round(beta1ggm,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/beta1ggm.txt",row.names=F,col.names=F,quote=F)
write.table(round(beta2ggm,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/beta2ggm.txt",row.names=F,col.names=F,quote=F)
write.table(round(beta1npn,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/beta1npn.txt",row.names=F,col.names=F,quote=F)
write.table(round(beta2npn,digits=4),"/users/qingyangzhang/desktop/DNetFinder_package/beta2npn.txt",row.names=F,col.names=F,quote=F)
beta1ggm=read.table("/users/qingyangzhang/desktop/DNetFinder_package/beta1ggm.txt",header=F)
beta2ggm=read.table("/users/qingyangzhang/desktop/DNetFinder_package/beta2ggm.txt",header=F)
beta1npn=read.table("/users/qingyangzhang/desktop/DNetFinder_package/beta1npn.txt",header=F)
beta2npn=read.table("/users/qingyangzhang/desktop/DNetFinder_package/beta2npn.txt",header=F)

trueN=matrix(0,p,p)
for(i in 1:50){
trueN[i,i+1]=1
trueN[i+1,i]=1
}
myDN_GGM=DNetGGM(data1,data2,beta1ggm,beta2ggm,0.1)
myDN_NPN=DNetNPN(data1,data2,beta1npn,beta2npn,0.1)
sum((myDN_GGM-trueN)==1)/sum(myDN_GGM)
sum((myDN_NPN-trueN)==1)/sum(myDN_NPN)

myDN_GGM=DNetGGM(data1,data2,beta1ggm,beta2ggm,0.2)
myDN_NPN=DNetNPN(data1,data2,beta1npn,beta2npn,0.2)
sum((myDN_GGM-trueN)==1)/sum(myDN_GGM)
sum((myDN_NPN-trueN)==1)/sum(myDN_NPN)

myDN_GGM=DNetGGM(data1,data2,beta1ggm,beta2ggm,0.3)
myDN_NPN=DNetNPN(data1,data2,beta1npn,beta2npn,0.3)
sum((myDN_GGM-trueN)==1)/sum(myDN_GGM)
sum((myDN_NPN-trueN)==1)/sum(myDN_NPN)


myDN_GGM=DNetGGM(data1,data2,beta1ggm,beta2ggm,0.4)
myDN_NPN=DNetNPN(data1,data2,beta1npn,beta2npn,0.4)
sum((myDN_GGM-trueN)==1)/sum(myDN_GGM)
sum((myDN_NPN-trueN)==1)/sum(myDN_NPN)


#################################################################
## Direct estimator
## ==============================================================

## This file contains all source codes for implementing 
## the proposed direct estimator, including both the Lagrange multiplier 
## and PSM algorithms. To run the codes, users should install a few R packages 
## including ‘Rfast’, ‘mixtools’, ‘matrixcalc’, ‘network’, ‘flare’, 
##‘fastclime’, ‘genefu’

## ==============================================================

library(Rfast)
library(mixtools)
library(matrixcalc)
library(network)
library(flare)
library(fastclime)
library(genefu)


## Part 1: Rank-based estimator for covariance matrix

unadj_cor=cor(sim_data, method="spearman") # unadjusted sample Spearman’s correlation matrix 

adj_cor=matrix(0, p, p)

for(i in 1:p){
   for(j in 1:p){
       adj_cor=2*sin(pi/6*unadj_cor)    
   }
}

## For illustrative purposes, consider an exponentially decayed correlation pattern

library(Rfast)

p=10 # p is the dimension of networks
 
rho=0.8

cormat=matrix(0, p, p)

for(i in 2:p){
   for(j in 1:(i-1)){
     cormat[i, j]=rho^(abs(i-j))
   }    
}

cormat=cormat+t(cormat)

diag(cormat)=1

N=200

sim_data=rmvnorm(N, rep(0, p), cormat)

unadj_cor=cor(sim_data, method="spearman") # unadjusted sample Spearman’s correlation matrix 

adj_cor=matrix(0, p, p)

for(i in 1:p){

   for(j in 1:p){

       adj_cor=2*sin(pi/6*unadj_cor) # adjusted sample Spearman’s correlation, which is asymptotically unbiased

   }
}


## ==============================================================
## Part 2: Data generation using BA model (see descriptions in simulation study)


p=120 # number of nodes

adjmat=matrix(0,p,p) # adjacency matrix 0/1, upper triangular 

# initializing a five-node loop…

adjmat[1,2]=1 
 
adjmat[2,3]=1 

adjmat[3,4]=1

adjmat[4,5]=1

adjmat[5,1]=1

adjmat=adjmat+t(adjmat)

## BA model starting from node 6

for(i in 6:p){

    exist_deg=colSums(adjmat[,c(1:(i-1))])
    connect_to=sample(c(1:(i-1)),1,prob=exist_deg/sum(exist_deg))

    adjmat[i, connect_to]=1
    adjmat[connect_to, i]=1

}

cormat=matrix(0, p, p)

for(i in 1:p){
   for(j in 1:i){
     if(adjmat[i,j]!=0){

       cormat[i,j]=sample(c(-1,1), 1, prob=c(0.5,0.5))*runif(1,1/4,1/2)

       cormat[j,i]=cormat[i,j]

     }  
   }
}

## Now we scale the off-diag elements in the matrix to ensure positive definiteness

## The diagonal elements are set to be 1

pvec=c(40, 60, 90, 120)

constvec=2:5 # using 2,3,4,5 for p=40,60,90,120, respectively 

scaling_const=function(p){

return(constvec[which(pvec==p)])

}

cormat=cormat/scaling_const(p)

diag(cormat)=1

# checking whether the correlation matrix is positive definite

if(!is.positive.definite(cormat)){

     cat("Stop!! The correlation matrix is NOT positive definite") 

     }
  
## Differential network generation in sparse setting (refer to simulation study)

prop=0.2
prop_e=0.4 # proportion of edges
prop_n=0.2 # proportion of nodes, see descriptions in the simulation study

cormat_y=matrix(0,p,p)

diag(cormat_y)=1/2

for(i in 1:p){
for(j in 1:p){

if(i>j){

cormat_y[i,j]=cormat[i,j]*sample(c(-1,1), 1, prob=c(prop,1-prop))

}

}
}

cormat_y=cormat_y+t(cormat_y)


## Differential network generation in dense setting (refer to simulation study)

cormat_y=matrix(0,p,p)

diag(cormat_y)=1/2

inout_degree=rowSums(adjmat)

cutoff=quantile(inout_degree,1-prop_n)

node_high_connectivity_index=which(inout_degree>cutoff)

for(i in 1:p){
for(j in node_high_connectivity){

if(i>j){

cormat_y[i,j]=cormat[i,j]*sample(c(-1,1), 1, prob=c(prop_e,1-prop_e))

}
}

cormat_y=cormat_y+t(cormat_y)

## ====================Part 3: Lagrange multiplier (oracle data, Zhao et al.’s method, Biometrika, 2014) 
and PSM algorithm (Pang et al. (2014), JMLR) =================

## provided by Dr. Sihai Zhao with C subroutine called

dpm <- function(X1, X0, lambda=NULL, nlambda=10,lambda.min.ratio=NULL,

                rho=NULL, shrink=NULL, prec=0.001, max.ite=100,

                correlation=FALSE, perturb=FALSE,

                tuning=c("none","aic","bic","cv"),folds=5) # here we used folds=5 in the simulation study
{
   
    ## calculate covariance matrices

****—    if(ncol(X1)!=ncol(X0))
        {
            cat("X1 and X0 need to have the same number of columns.\n");
            return(NULL);
        }

    n1 <- nrow(X1); n0 <- nrow(X0);

    ## the number of parameters is p(p+1)/2

    p <- ncol(X1); d <- p*(p+1)/2;

    maxdf <- max(n1,n0,d);
    
    ## ****** construct kronecker product

if(correlation){ S1 <- cor(X1); S0 <- cor(X0); } else
        { S1 <- cov(X1)*(1-1/n1); S0 <- cov(X0)*(1-1/n0); }

if(is.logical(perturb))
        {
            if(perturb)
                {
                    ## same perturbation as the clime software

                    eigvals1 <- eigen(S1,only.values=TRUE)$values;

                    eigvals0 <- eigen(S0,only.values=TRUE)$values;

                    perturb1 <- max(max(eigvals1)-p*min(eigvals1),0)/(p-1);

                    perturb0 <- max(max(eigvals0)-p*min(eigvals0),0)/(p-1);

                } 
            else { perturb1 <- 0; perturb0 <- 0; }
}

    S <- kronecker(S0+diag(p)*perturb0,S1+diag(p)*perturb1);

    gc(reset=TRUE);
    
    if(is.null(rho)){ rho <- sqrt(d); }

    if(is.null(shrink)){ shrink <- 1.5; }
  ****—  

    ind <- matrix(1:p^2,nrow=p);

    lowtri <- lower.tri(ind,diag=TRUE);

    S[,ind[lowtri]] <- S[,ind[lowtri]]+S[,t(ind)[lowtri]];

    S[,diag(ind)] <- S[,diag(ind)]/2;

    S <- S[,ind[lowtri]];

    S[ind[lowtri],] <- S[ind[lowtri],]+S[t(ind)[lowtri],];

    S[diag(ind),] <- S[diag(ind),]/2;

    S <- S[ind[lowtri],];

    e <- as.vector(S1-S0);

    e[ind[lowtri]] <- 2*e[ind[lowtri]];

    e[diag(ind)] <- e[diag(ind)]/2;

    e <- e[ind[lowtri]];

    gc(reset=TRUE);
    
    diags <- diag(p)[lowtri];
   

if(!is.null(lambda)){ nlambda <- length(lambda); }

if(is.null(lambda)){

            if(is.null(lambda.min.ratio)){ lambda.min.ratio <- 0.04; }

            lambda.max <- max(abs(e));

            lambda.min <- lambda.min.ratio*lambda.max;

            lambda <- exp(seq(log(lambda.max),log(lambda.min), length=nlambda));
}

## call C subroutine here

gamma <- 1/rho;

lambda <- lambda - shrink*prec;

nlambda = length(lambda);

ret = vector("list", nlambda);

diff = .C("dpm", as.double(S), diff=double(d*nlambda),
        as.integer(d), as.integer(diags),as.double(lambda),
        as.integer(nlambda), as.double(gamma), as.integer(max.ite),
        as.double(prec), as.double(e))$diff;

for(i in 1:nlambda)
    {
        ret[[i]] <- matrix(NA,nrow=p,ncol=p);
        ret[[i]][ind[lowtri]] <- diff[((i-1)*d+1):(i*d)];
        ret[[i]][t(ind)[lowtri]] <- diff[((i-1)*d+1):(i*d)];
    }
    
rm(list=c("S","diff","ind","lowtri")); gc(reset=TRUE);
    
opt <- switch(tuning[1], ## default is "none"
                  none=NA,
                  cv=dpm.cv(X1,X0,
                      lambda,
                      rho,shrink,prec,max.ite,
                      correlation,perturb,
                      folds),
                  aic=dpm.ic(S1,S0,ret,n1+n0,2),
                  bic=dpm.ic(S1,S0,ret,n1+n0,log(n1+n0)));

if(!is.na(opt[1])){ names(opt) <- c("max","1","L1","sp","F","nc"); }
    
    return(list(dpm=ret,lambda=lambda,nlambda=nlambda,opt=opt));
}


loss <- function(D,S1,S0)
{
    err <- S1%*%D%*%S0-S1+S0;

    return(c(max(abs(err)), ## max

             sum(abs(err)), ## l1, element-wise

             max(apply(err,1,function(r){ sum(abs(r)) })), ## matrix L1

             svd(err,nu=0,nv=0)$d[1], ## spectral

             sqrt(sum(err^2)), ## frobenius

             sum(svd(err,nu=0,nv=0)$d))); ## nuclear
}

## **************************************************************
dpm.cv <- function(X1,X0,
                   lambda=NULL,
                   rho=NULL,shrink=NULL,prec=0.001,max.ite=100,
                   correlation=FALSE,perturb=FALSE,
                   folds=5)
{
  if(ncol(X1)!=ncol(X0))
  {
    cat("X1 and X0 need to have the same number of columns.\n");
    return(NULL);
  }

  n1 <- nrow(X1); n0 <- nrow(X0);

  p <- ncol(X1); d <- p*(p+1)/2;

  if(is.null(rho)){ rho <- sqrt(d); }

  if(is.null(shrink)){ shrink <- 1.5; }
  
  ind1 <- sample(1:n1,n1,replace=FALSE);

  ind0 <- sample(1:n0,n0,replace=FALSE);

  losses <- array(NA,c(folds,6,length(lambda)));

for(i in 1:folds){

    cat("",i);

    test1 <- ind1[((i-1)*n1/folds+1):(i*n1/folds)];

    test0 <- ind0[((i-1)*n0/folds+1):(i*n0/folds)];

    fit <- dpm(X1[-test1,],X0[-test0,],lambda,lenth(lambda),NULL,

               rho,shrink,prec,max.ite,correlation,perturb,tuning="none");

if(correlation)
    { S1.test <- cor(X1[test1,]); S0.test <- cor(X0[test0,]); } else
    {
      S1.test <- cov(X1[test1,])*(1-1/length(test1));
      S0.test <- cov(X0[test0,])*(1-1/length(test0));
    }

    losses[i,,] <- sapply(fit$dpm,loss,S1.test,S0.test);
  }

opt <- apply(apply(losses,c(2,3),mean),1,which.min);

return(opt);

}


dpm.ic <- function(S1,S0,ret,n,penalty)
{
    lowtri <- which(lower.tri(ret[[1]],diag=TRUE));

    df <- sapply(ret,function(x){ sum(x[lowtri]!=0); });

    ic <- scale(n*sapply(ret,loss,S1,S0),center=-penalty*df,scale=FALSE);

    return(apply(ic,1,which.min));
}

## C subroutine (from Dr. Sihai Zhao’s Github)

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "R.h"

void dpm(double * Sigma, double * omg, int *dd, int *diags, double * lambda, int *nnlambda, double * gamma, int * max_ite, double * prec, double * e_i)
{
    int i,j,k,m,dim,junk_a,size_a,size_a_pre,w_idx,rs_idx,nlambda;
    int ite_ext,ite_int1,ite_int2,gap_ext,max_ite1,max_ite2,max_ite3, tmp_m;
    double gap_int,ilambda,tmp1,tmp2,err1,err2,omg_2norm,mu_2norm,omg_dif,eps1,eps2,omg_temp,alp_dif,mu_dif,max_dif;
    double omg_sum1, omg_sum2, omg_dif_sum1, omg_out1;

    dim = *dd;
    //dim_sq = dim*dim;
    nlambda = *nnlambda;

    
double *omg0 = (double*) malloc(dim*sizeof(double));
    
double *omg1 = (double*) malloc(dim*sizeof(double));
   
int *idx_a = (int*) malloc(dim*sizeof(int)); 

int *idx_i = (int*) malloc(dim*sizeof(int)); 
  
double *alp_tild = (double*) malloc(dim*sizeof(double));
    
double *mu_grad = (double*) malloc(dim*sizeof(double));

double *omg_grad = (double*) malloc(dim*sizeof(double));

double *omg_pre = (double*) malloc(dim*sizeof(double));

double *alp = (double*) malloc(dim*sizeof(double));

double *mu = (double*) malloc(dim*sizeof(double));

double *S_col = (double*) malloc(dim*sizeof(double));

double *gamma_col = (double*) malloc(dim*sizeof(double));

double *S_omg = (double*) malloc(dim*sizeof(double));

double *omg_tild = (double*) malloc(dim*sizeof(double));

double *r = (double*) malloc(dim*sizeof(double));

double *y_i = (double*) malloc(dim*sizeof(double));

double *SS = (double*) malloc(dim*dim*sizeof(double));

double *Sy = (double*) malloc(dim*sizeof(double));

    
max_ite1 = * max_ite;
    
max_ite2 = 1e2;
    
max_ite3 = 1e2;
    
eps1 = * prec;
    
eps2 = 1e-3;
    //
cnz = 0;
    
for(i=0; i<dim; i++){
        S_col[i] = 0;
        for(j=0; j<dim; j++){
            SS[j*dim+i] = 0;
            for(k=0; k<dim; k++)
                SS[j*dim+i] += Sigma[k*dim+i]*Sigma[j*dim+k];
        }
        S_col[i] = SS[i*dim+i];
        gamma_col[i] = *gamma/S_col[i];
    }

        size_a = 0;
   
for(m=0; m<nlambda; m++) {

	    tmp_m=m*dim; // 

            max_dif = 1;

            while(max_dif > eps1 && ite_ext < max_ite1){
                
for(j=0; j<dim; j++){
                    S_omg[j]=0;
                    for(k=0; k<size_a; k++){
                        w_idx = idx_a[k];
                        S_omg[j]+=Sigma[w_idx*dim+j]*omg0[w_idx];
                    
}
                    
alp_tild[j]=e_i[j]-S_omg[j]-mu[j];
                
}
                
alp_dif = 0;

for(j=0; j<dim; j++){
		  // 
change lambda for diagonal elements

ilambda = lambda[m];
		  
if(diags[j]==1){
		    ilambda = lambda[m]/2;
		  }
                    if (alp_tild[j]<=-ilambda){
                        alp[j]=-ilambda;
                        alp_dif = fabs(alp_tild[j]+ilambda)>alp_dif ? fabs(alp_tild[j]+ilambda) : alp_dif;
                    }
                    else {
                        if (alp_tild[j]>=ilambda){
                            alp[j] = ilambda;
                            alp_dif = fabs(alp_tild[j]-ilambda)>alp_dif ? fabs(alp_tild[j]-ilambda) : alp_dif;
                        }
                        else
                            alp[j] = alp_tild[j];
                    }
}


                for(j=0; j<dim; j++)

                    y_i[j] = e_i[j]-alp[j]-mu[j];

                for(j=0; j<dim; j++){

                    Sy[j] = 0;
                    omg_pre[j] = omg0[j];
                    for(k=0; k<dim; k++){

                        Sy[j] += Sigma[j*dim+k]*y_i[k];
                    }
                }

gap_ext = 1;

ite_int1 = 0;

while(gap_ext !=0 && ite_int1<max_ite2){

size_a_pre = size_a;

for(j=0; j<dim; j++){
                        
if(idx_i[j] == 1){
                            
omg_tild[j] = 0;
                            
for(k=0; k<size_a; k++){
                                
w_idx = idx_a[k];
                                
omg_tild[j] += SS[w_idx*dim+j]*omg0[w_idx];
                            
}

                            
omg_tild[j] = (Sy[j]-omg_tild[j]+S_col[j]*omg0[j])/S_col[j];
                            
if(fabs(omg_tild[j])<=gamma_col[j]) {
                                
omg1[j] = 0;
                            }

                            
else{

                                
if(omg_tild[j]>gamma_col[j])
                                    
omg1[j] = omg_tild[j] - gamma_col[j];
                               
                    else
                                    
omg1[j] = omg_tild[j] + gamma_col[j];
                                
idx_a[size_a] = j;
                                
size_a++;
                                
idx_i[j] = 0;
                            }

                            omg0[j] = omg1[j];
                        }
                    
}

                    gap_ext = size_a - size_a_pre;
                    gap_int = 1;
                    ite_int2 = 0;

while(gap_int>eps2 && ite_int2<max_ite3){
                        
tmp1 = 0;
                        
tmp2 = 0;
                        
for(j=0; j<size_a; j++){
                            
w_idx = idx_a[j];
                            
omg_tild[w_idx] = 0;
                            
for(k=0; k<size_a; k++){
                                
rs_idx = idx_a[k];
                                
omg_tild[w_idx] += SS[rs_idx*dim+w_idx]*omg0[rs_idx];
                            
}
                            
omg_tild[w_idx] = (Sy[w_idx]-omg_tild[w_idx]+S_col[w_idx]*omg0[w_idx])/S_col[w_idx];
                            
if (fabs(omg_tild[w_idx]) <= gamma_col[w_idx]) {
                                
omg1[w_idx] = 0;
                            
}
                            
else {
                                
if (omg_tild[w_idx]>gamma_col[w_idx])
                                    
omg1[w_idx] = omg_tild[w_idx] - gamma_col[w_idx];
                                
       else
                                    
omg1[w_idx] = omg_tild[w_idx] + gamma_col[w_idx];
                                
tmp2 = tmp2+fabs(omg1[w_idx]);
                            }
                            omg_dif = omg1[w_idx]-omg0[w_idx];
                            tmp1 = tmp1+fabs(omg_dif);
                            omg0[w_idx] = omg1[w_idx];
                        }
                        gap_int = tmp1/tmp2;
                        ite_int2++;
                    }
                    //ite_cnt_int2[m*dim+i] += ite_int2;

                    junk_a = 0;
                    for(j=0; j<size_a; j++){
                        w_idx = idx_a[j];
                        if (omg1[w_idx] == 0){
                            junk_a++;
                            idx_i[w_idx] = 1;
                        }
                        else
                            idx_a[j-junk_a] = w_idx;
                    }
                    size_a = size_a - junk_a;
                    ite_int1++;
                }
                //ite_cnt_int1[m*dim+i] += ite_int1;

omg_sum1 = 0;
omg_dif_sum1 = 0;
omg_sum2 = 0;
for(j=0; j<dim; j++){
                    //omg_dif_sum1 += fabs(omg_pre[j] - omg0[j]);
                    omg_sum1 += fabs(omg0[j]);
                    omg_sum2 += fabs(omg_pre[j]);
                    S_omg[j]=0;
                    for(k=0; k<size_a; k++){
                        w_idx = idx_a[k];
                        S_omg[j]+=Sigma[w_idx*dim+j]*omg1[w_idx];
                    }
                }
                //omg_out1 = omg_dif_sum1/omg_sum1;
                omg_out1 = fabs(omg_sum2-omg_sum1)/omg_sum1;

                // update mu
                mu_dif = 0;
                for(j=0; j<dim; j++){
                    mu_grad[j]=alp[j]+S_omg[j]-e_i[j];
                    mu[j] += mu_grad[j];
                    mu_dif = fabs(mu_grad[j])>mu_dif ? fabs(mu_grad[j]) : mu_dif;
                }
                max_dif = omg_out1>mu_dif ? omg_out1 : mu_dif;
                ite_ext++;
            }
            //ite_cnt_ext[m*dim+i] = ite_ext;
	    
for(j=0;j<size_a;j++){
    w_idx = idx_a[j];
    omg[tmp_m+w_idx] = omg1[w_idx];
            }
}
} 

## the PSM part is modified from FASTCLIME package by Pang et al. (2014)
## Users should calculate rank-based spearman’s correlation matrix, and construct the S matrix and A vector (this part ****——****) (see implementation part in the paper, and feed into the following C program)

#include "myalloc.h"
#include "lu.h"
#include "linalg.h"
#include "macros.h"


#define EPS1 1.0e-8
#define EPS2 1.0e-12
#define EPS3 1.0e-5
#define MAX_ITER 1000000

static int status0;
static double lambda0;
static double *x;

int ratio_test0(
	double *dy, 
	int   *idy,
	int    ndy,
	double *y, 
        double *ybar,
	double mu
);


void solver20(
    int m,		
    int n,		
    int nz,		
    int *ia, 		
    int *ka, 		
    double *a,		
    double *b, 		
    double *c          
    );



void fastlp(double *obj, double *mat, double *rhs, int *m0 , int *n0, double *opt, int *status, double *lambda)
{

    int m=*m0;		
    int n=*n0;		
    int nz=0;		
    int *ia; 		
    int *ka; 		
    double *a;		
    double *b; 		/* right-hand side */
    double *c;          /* objective coefficients */
    int i, j, k; 
    status0 = *status;
    lambda0 = *lambda;

    if(lambda0<=EPS3){
      lambda0=EPS3;
    }


    MALLOC(        a, m*n+m,  double );      
    MALLOC(       ia, m*n+m,   int );      
    MALLOC(       ka, n+m+1,  int );        
    MALLOC(        c, n,   double );
    MALLOC(        b, m,   double );    


    for (i=0;i<n;i++){
	c[i]=obj[i];
    }

    for (i=0;i<m;i++){
	b[i]=rhs[i];
    }

    for (i=0;i<m;i++){
       for(j=0;j<n;j++){
	
       }	
    }


    k=0;
	//Sparse matrix representation
    for (j=0; j<n; j++) {
	    ka[j] = k; 
	    for (i=0; i<m; i++) {
		  if (mat[i*n+j]!=0)
		  {
	            a[k] = mat[i*n+j];
		    ia[k] = i;
                    k++;
                    nz++;  
                  
		  }    
	    
	    }
    }
    ka[n]=k;
    solver20(m,n,nz,ia,ka,a,b,c);
    *status=status0;

    for(i=0;i<n;i++){
        opt[i]=x[i];
    }


void solver20(
    int m,		
    int n,		
    int nz,		
    int *ia, 		
    int *ka, 		
    double *a,		
    double *b, 		
    double *c          
    )
{

    int *basics;
    int *nonbasics;
    int *basicflag;
    double  *x_B;	
    double  *y_N;	
    double  *xbar_B;	
    double  *ybar_N;    
    double  *dy_N;	
    int    *idy_N;	
    int     ndy_N=0;	
    double  *dx_B;	
    int    *idx_B;	
    int     ndx_B;	
    double  *at;	
    int    *iat;
    int    *kat;
    int     col_in;	
    int     col_out;	
    int     iter = 0;	
    int     i,j,k,v=0;
    double  s, t, sbar, tbar, mu=HUGE_VAL;
    double  *vec;
    int    *ivec;
    int     nvec;
    int     N;

    N=m+n;

    i = 0;
    k = ka[n];
    for (j=n; j<N; j++) {	
	a[k] = 1.0;
	ia[k] = i;
	i++;
	k++;
	ka[j+1] = k;
    }
    nz = k;

    MALLOC(    x_B, m,   double );      
    MALLOC( xbar_B, m,   double );      
    MALLOC(   dx_B, m,   double );  
    MALLOC(    y_N, n,   double );
    MALLOC( ybar_N, n,   double );           
    MALLOC(   dy_N, n,   double );  
    MALLOC(    vec, N,   double );
    MALLOC(   ivec, N,    int );
    MALLOC(  idx_B, m,    int );      
    MALLOC(  idy_N, n,    int );      
    MALLOC(     at, nz,  double );
    MALLOC(    iat, nz,   int );
    MALLOC(    kat, m+1,  int );
    MALLOC(   basics,    m,   int );      
    MALLOC(   nonbasics, n,   int );      
    MALLOC(   basicflag, N,   int );
    CALLOC(   x, N, double );


    atnum(m,N,ka,ia,a,kat,iat,at);

    for (j=0; j<n; j++) {
	nonbasics[j] = j;
	basicflag[j] = -j-1;
	      y_N[j] = -c[j];
           ybar_N[j] = 1;
    }

    for (i=0; i<m; i++) {
	    basics[i] = n+i;
       basicflag[n+i] = i;
	       x_B[i] = b[i];
	    xbar_B[i] = 1;
    }

    lufac( m, ka, ia, a, basics, 0 );

 for (iter=0; iter<MAX_ITER; iter++) {



      mu = -HUGE_VAL;
      col_in  = -1;
      for (j=0; j<n; j++) {
		if (ybar_N[j] > EPS2) { 
			if ( mu < -y_N[j]/ybar_N[j] ) {
			     mu = -y_N[j]/ybar_N[j];
			     col_in  = j;
			}
		}
      }
      col_out = -1;

     for (i=0; i<m; i++) {
		if (xbar_B[i] > EPS2) { 
			if ( mu < -x_B[i]/xbar_B[i] ) {
			     mu = -x_B[i]/xbar_B[i];
			     col_out = i;
			     col_in  = -1;
			}
		}
      }
     
       if ( mu <= lambda0 ) {	/* optimal */
          status0=0;       
	  break;

      }

if ( col_out >= 0 ) {

	vec[0] = -1.0;
	ivec[0] = col_out;
	nvec = 1;

	btsolve( m, vec, ivec, &nvec );  
	Nt_times_y( N, at, iat, kat, basicflag, vec, ivec, nvec, 
		     dy_N, idy_N, &ndy_N );

	col_in = ratio_test0( dy_N, idy_N, ndy_N, y_N, ybar_N,mu );


	if (col_in == -1) { 	/* infeasible */
	    status0 = 1;
	    break;
	}


	j = nonbasics[col_in];
	for (i=0, k=ka[j]; k<ka[j+1]; i++, k++) {
	     dx_B[i] =  a[k];
	    idx_B[i] = ia[k];
	}
	ndx_B = i;
	bsolve( m, dx_B, idx_B, &ndx_B );

        }

        else {


	j = nonbasics[col_in];
	for (i=0, k=ka[j]; k<ka[j+1]; i++, k++) {
	     dx_B[i] =  a[k];
	    idx_B[i] = ia[k];
	}
	ndx_B = i;
	bsolve( m, dx_B, idx_B, &ndx_B );


	col_out = ratio_test0( dx_B, idx_B, ndx_B, x_B, xbar_B, mu );

	if (col_out == -1) {	/* UNBOUNDED */
	    status0 = 2;
	    break;
	}


	 vec[0] = -1.0;
	ivec[0] = col_out;
	nvec = 1;

	btsolve( m, vec, ivec, &nvec );  		
	Nt_times_y( N, at, iat, kat, basicflag, vec, ivec, nvec, 
		     dy_N, idy_N, &ndy_N );

      }


      for (k=0; k<ndx_B; k++) if (idx_B[k] == col_out) break;

      t    =    x_B[col_out]/dx_B[k];
      tbar = xbar_B[col_out]/dx_B[k];

      for (k=0; k<ndy_N; k++) if (idy_N[k] == col_in) break;

      s    =    y_N[col_in]/dy_N[k];
      sbar = ybar_N[col_in]/dy_N[k];


      for (k=0; k<ndy_N; k++) {
		j = idy_N[k];
		y_N[j]    -= s   *dy_N[k];
                ybar_N[j] -= sbar*dy_N[k];
      }
      
      y_N[col_in]    = s;
      ybar_N[col_in] = sbar;

      for (k=0; k<ndx_B; k++) {
		i = idx_B[k];
		x_B[i]    -= t   *dx_B[k];
		xbar_B[i] -= tbar*dx_B[k];

      }

      x_B[col_out]     = t;
      xbar_B[col_out]  = tbar;


      i =    basics[col_out];
      j = nonbasics[col_in];
      basics[col_out]   = j;
      nonbasics[col_in] = i;
      basicflag[i] = -col_in-1;
      basicflag[j] = col_out;


      refactor( m, ka, ia, a, basics, col_out, v );

  } 

for (i=0; i<m; i++) {

	  x[basics[i]] = x_B[i];

      }

if(iter>=1){
          Nt_times_y( -1, at, iat, kat, basicflag, vec, ivec, nvec, 
		     dy_N, idy_N, &ndy_N );
      }

if(iter>=1){
       lu_clo();
       btsolve(0, vec, ivec, &nvec);
       bsolve(0, vec, ivec, &nvec);
    }

}


int ratio_test0(
	double *dy, 
	int   *idy,
	int    ndy,
	double *y, 
	double *ybar, 
	double mu
)
{
	int j, jj = -1, k;
	double min = HUGE_VAL;

for (k=0; k<ndy; k++) 
if ( dy[k] > EPS1 ) {
	j = idy[k];
if ( (y[j] + mu*ybar[j])/dy[k] < min ) {
			min = (y[j] + mu*ybar[j])/dy[k];
			 jj = j;
		}
	    }
	}

	return jj;
}


## ================== Part 5: likelihood based classification ==========================

# delta_hat is the vector estimated coefficients in the differential network, of size p-squared

library(mixtools) # function “normalmixEM”

# initial guess for mean, sd and proportion vectors (of size 3)

# initial guess for + group 

lam_pos=sum(delta_hat>0)/p^2

mu_pos=mean(delta_hat[delta_hat>0])

sd_pos=sd(delta_hat[delta_hat>0])

# initial guess for - group

lam_neg=sum(delta_hat<0)/p^2

mu_neg=mean(delta_hat[delta_hat<0])

sd_neg=sd(delta_hat[delta_hat<0])

# initial guess for 0 group

lam_0=sum(delta_hat==0)/p^2

mu_0=0

sd_0=0.01

normalmixEM(delta_hat, lambda = c(lam_pos,lam_neg,lam_0), mu = c(mu_pos, mu_neg, mu_0), 

sigma = c(sd_pos, sd_neg, sd_0), k = 3, 

mean.constr = NULL, sd.constr = NULL,

epsilon = 1e-06, maxit = 1000, maxrestarts=20, 

verb = FALSE, fast=FALSE, ECM = FALSE,

arbmean = TRUE, arbvar = TRUE) 

# We used epsilon=1e-06 in both simulation study and real data application. 


## construction of ROC curves, TPR, TNR etc 

# est_diff —- the estimated coefficients in delta, vectorized
# true_diff —- the true coefficients in delta, vectorized

thresholds=seq(max(est_diff),min(est_diff),(max(est_diff)-min(est_diff))/1000)

n=length(thresholds)

sens=numeric(n) # vector of sensitivities

spec=numeric(n) # vector of specificities

for(i in 1:n){

   sens[i]=sum(est_idff>thresholds[i] & true_diff!=0)/sum(true_diff!=0)

   spec[i]=sum(est_diff<thresholds[i] & true_diff==0)/sum(true_diff==0)
}

plot(1-spec,sens,type="o",xlim=c(0,1),ylim=c(0,1),lty=4,lwd=2,col="red")

abline(0,1,col="green")

## calculate area under curve (concordance index) 

AUC=0

for(i in 1:(n-1)){

   trapezoid=(sens[i]+sens[i+1])*(spec[i]-spec[i+1])/2

   AUC=AUC+trapezoid
}

TPR=sum(true_diff*est_diff>0)/sum(true_diff>0)

TNR=sum(true_diff^2+est_diff^2==0)/sum(true_diff==0)

## Linux based parallel computing (users should use parallel computing to reproduce the simulation study, as the proposed algorithm is computationally expensive) ################

A sample job script is provided below (submit to job queue with the C subroutine) ========

#PBS -N Direct_Estimation.R

#PBS -q tiny12core

#PBS -j oe

#PBS -m ae

#PBS -o zzz.$PBS_JOBID.tiny

#PBS -l nodes=2:ppn=12,walltime=10:00:00

module purge

module load intel/14.0.3 impi/5.1.1

cd $PBS_O_WORKDIR 

NP=$(wc -l < $PBS_NODEFILE)

mpirun -np $NP -machinefile $PBS_NODEFILE  ./mympiexecutable


## =================== Reading TCGA raw data for OV and BRCA =======
Alternatively, one can download the processed TCGA data from====== 
CBioPortal at http://www.cbioportal.org/datasets, however,====== 
the results may be slightly different ==========================

path="/TCGA_data/OV/Expression_Genes"

filenames=list.files(path)

n=length(filenames)

currentdata=read.table(paste(path,"/",filenames[1],sep=""),skip=3)

IDnumber=as.character(currentdata[1,1])

fulldata=currentdata[,c(2,3)]

    for(i in 2:n){

   currentdata=read.table(paste(path,"/",filenames[i],sep=""),skip=3)

   IDnumber=c(IDnumber,as.character(currentdata[1,1]))

   fulldata=cbind(fulldata,currentdata[,3])
}

===================== R codes for generating the network======== 
===================== plots (Figures 5 and 6) using network package======

library(network)

clus1=as.matrix(clus1)

g=network(clus1,directed=F)

lot=network.layout.circle(g, layout.par)

plot(g,label=path_names,label.pos=9,label.cex=0.5,vertex.col="white",
vertex.cex=0,edge.lwd=0.5,edge.col="red",mode="circle",
boxed.labels = FALSE)











